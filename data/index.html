<!doctype html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NeoGoat Deck Builder</title>
  <style>
    body { margin:0; background:#0b0b0b; color:#f2f2f2; font-family:system-ui, sans-serif; }
    header { padding:14px 16px; border-bottom:1px solid #222; display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .tag { font-size:12px; opacity:.9; border:1px solid #333; padding:4px 8px; border-radius:999px; }
    main { display:grid; grid-template-columns: 1fr 420px; gap:14px; padding:14px; }
    input, button, select { font:inherit; }
    input { width: min(520px, 100%); padding:10px 12px; border-radius:10px; border:1px solid #333; background:#121212; color:#f2f2f2; }
    select { padding:9px 10px; border-radius:10px; border:1px solid #333; background:#121212; color:#f2f2f2; }
    button { padding:8px 10px; border-radius:10px; border:1px solid #333; background:#151515; color:#f2f2f2; cursor:pointer; }
    button:hover { background:#1a1a1a; }
    .card { border:1px solid #222; border-radius:14px; padding:12px; background:#101010; }
    .row { display:flex; justify-content:space-between; gap:10px; align-items:flex-start; }
    .name { font-weight:800; }
    .meta { font-size:12px; opacity:.82; margin-top:2px; }
    .small { font-size:12px; opacity:.82; }
    .list { display:flex; flex-direction:column; gap:10px; }
    .results { max-height: calc(100vh - 148px); overflow:auto; }
    .deck { max-height: calc(100vh - 148px); overflow:auto; }
    .err { color:#ff8080; font-size:12px; margin-top:6px; }
    .ok { color:#8fff8f; font-size:12px; margin-top:6px; }
    .counts { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    .pill { font-size:12px; border:1px solid #333; padding:4px 8px; border-radius:999px; }
    .muted { opacity:.7; }
    .btns { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .tabs { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    .tab { padding:7px 10px; border-radius:999px; border:1px solid #333; background:#131313; cursor:pointer; font-size:12px; }
    .tab.active { background:#1b1b1b; border-color:#444; }
    .gridFilters { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    a { color:#9ad1ff; text-decoration:none; }
    a:hover { text-decoration:underline; }
  </style>
</head>
<body>
  <header>
    <div style="display:flex; flex-direction:column; gap:2px;">
      <div style="font-weight:900; font-size:18px;">NeoGoat Deck Builder</div>
      <div class="small muted" id="status">Cargando datos…</div>
    </div>
    <span class="tag" id="formatTag">Formato: —</span>
    <div style="flex:1;"></div>

    <input id="q" placeholder="Buscar carta (nombre)…" autocomplete="off" />

    <div class="btns">
      <button id="saveBtn" title="Guardar (local)">Save</button>
      <button id="loadBtn" title="Cargar (local)">Load</button>
      <button id="newBtn" title="Nuevo deck">New</button>
      <button id="importBtn" title="Importar decklist">Import</button>
      <button id="exportBtn" title="Exportar decklist">Export</button>
    </div>
  </header>

  <main>
    <section class="card">
      <div class="row">
        <div>
          <div style="font-weight:900;">Resultados</div>
          <div class="small muted">Solo cartas legales del formato activo.</div>
        </div>
        <div class="small muted" id="resultCount">0</div>
      </div>

      <div class="gridFilters">
        <select id="fType"><option value="">Type: All</option></select>
        <select id="fAttr"><option value="">Attribute: All</option></select>
        <select id="fMType"><option value="">Monster Type: All</option></select>
        <select id="fLimit"><option value="">Limit: All</option><option value="0">0 (Forbidden)</option><option value="1">1</option><option value="2">2</option><option value="3">3</option></select>
      </div>

      <div style="height:10px;"></div>
      <div class="results list" id="results"></div>
    </section>

    <aside class="card deck">
      <div class="row">
        <div>
          <div style="font-weight:900;">Deck</div>
          <div class="small muted">Límite global por carta (Main+Extra+Side).</div>
        </div>
        <div class="small" id="totalCount">0</div>
      </div>

      <div class="tabs">
        <div class="tab active" data-tab="main">Main <span class="muted" id="mainCount">(0)</span></div>
        <div class="tab" data-tab="extra">Extra <span class="muted" id="extraCount">(0)</span></div>
        <div class="tab" data-tab="side">Side <span class="muted" id="sideCount">(0)</span></div>
      </div>

      <div class="counts">
        <span class="pill" id="sizePill">Tamaños: —</span>
        <span class="pill" id="legalPill">Legalidad: —</span>
        <span class="pill" id="limitPill">Límites: —</span>
      </div>

      <div id="deckErrors" class="err" style="display:none;"></div>

      <div style="height:12px;"></div>
      <div class="list" id="deckList"></div>

      <div style="height:12px;"></div>
      <div class="small muted">
        Guardado local: se guarda en tu navegador (localStorage).
      </div>
    </aside>
  </main>

<script>
(async function () {
  const elStatus = document.getElementById('status');
  const elFormatTag = document.getElementById('formatTag');
  const elResults = document.getElementById('results');
  const elDeck = document.getElementById('deckList');
  const elQ = document.getElementById('q');
  const elResultCount = document.getElementById('resultCount');
  const elErrors = document.getElementById('deckErrors');
  const elLegalPill = document.getElementById('legalPill');
  const elLimitPill = document.getElementById('limitPill');
  const elSizePill = document.getElementById('sizePill');
  const elTotalCount = document.getElementById('totalCount');
  const elMainCount = document.getElementById('mainCount');
  const elExtraCount = document.getElementById('extraCount');
  const elSideCount = document.getElementById('sideCount');

  const fType = document.getElementById('fType');
  const fAttr = document.getElementById('fAttr');
  const fMType = document.getElementById('fMType');
  const fLimit = document.getElementById('fLimit');

  const LS_KEY = 'neogoat_deck_local_v1';

  const state = {
    formatId: null,
    meta: null,
    cards: null,
    rules: null,
    legalIds: [],
    tab: 'main', // main|extra|side
    deck: {
      main: new Map(),
      extra: new Map(),
      side: new Map()
    }
  };

  function fmtCardMeta(c) {
    const parts = [];
    if (c.type) parts.push(c.type);
    if (c.subType) parts.push(c.subType);
    if (c.attribute) parts.push(c.attribute);
    if (c.monsterType) parts.push(c.monsterType);
    if (Number.isFinite(c.level)) parts.push('LV ' + c.level);
    if (Number.isFinite(c.atk) || Number.isFinite(c.def)) parts.push(`${c.atk ?? '?'} / ${c.def ?? '?'}`);
    return parts.filter(Boolean).join(' • ');
  }

  function getRule(id) { return state.rules?.[id] ?? null; }
  function getLimit(id) { return getRule(id)?.limit ?? null; }
  function isLegal(id) { const r=getRule(id); return !!(r && r.legal === true); }

  function countMap(m){ let t=0; for (const v of m.values()) t+=v; return t; }
  function deckCounts(){
    const main=countMap(state.deck.main);
    const extra=countMap(state.deck.extra);
    const side=countMap(state.deck.side);
    return {main, extra, side, total: main+extra+side};
  }

  function totalCopiesOf(id){
    return (state.deck.main.get(id)||0) + (state.deck.extra.get(id)||0) + (state.deck.side.get(id)||0);
  }

  function addTo(section, id) {
    if (!isLegal(id)) return;
    const lim = getLimit(id);
    const total = totalCopiesOf(id);
    if (lim !== null && total >= lim) return; // block adding beyond limit
    const m = state.deck[section];
    m.set(id, (m.get(id)||0) + 1);
    renderDeck();
  }

  function subFrom(section, id) {
    const m = state.deck[section];
    const cur = m.get(id)||0;
    if (cur <= 1) m.delete(id);
    else m.set(id, cur - 1);
    renderDeck();
  }

  function rmFrom(section, id) {
    state.deck[section].delete(id);
    renderDeck();
  }

  function renderDeck() {
    elDeck.innerHTML = '';

    const {main, extra, side, total} = deckCounts();
    elMainCount.textContent = `(${main})`;
    elExtraCount.textContent = `(${extra})`;
    elSideCount.textContent = `(${side})`;
    elTotalCount.textContent = total;

    const active = state.deck[state.tab];
    const lines = [];
    for (const [id, qty] of active.entries()) {
      const c = state.cards[id];
      if (!c) continue;
      lines.push({ id, qty, name: c.name || id });
    }
    lines.sort((a,b)=>a.name.localeCompare(b.name,'es'));

    for (const it of lines) {
      const c = state.cards[it.id];
      const lim = getLimit(it.id);
      const totalCopies = totalCopiesOf(it.id);
      const over = (lim !== null && totalCopies > lim);

      const row = document.createElement('div');
      row.className = 'card';
      row.innerHTML = `
        <div class="row">
          <div>
            <div class="name">${it.qty}x ${c.name ?? it.id}</div>
            <div class="meta">${fmtCardMeta(c)}</div>
            <div class="small muted">ID: ${it.id} • Limit: ${lim ?? '—'} • Total in deck: ${totalCopies}</div>
          </div>
          <div class="btns">
            <button data-act="add" data-id="${it.id}">+</button>
            <button data-act="sub" data-id="${it.id}">-</button>
            <button data-act="rm" data-id="${it.id}">x</button>
          </div>
        </div>
        ${over ? `<div class="err">Exceeds limit globally (${totalCopies}/${lim})</div>` : ``}
      `;
      elDeck.appendChild(row);
    }

    // Validation summary
    const illegal = [];
    const limitIssues = [];
    for (const [id, r] of Object.entries(state.rules || {})) {
      // nothing
    }
    const allIds = new Set([
      ...state.deck.main.keys(),
      ...state.deck.extra.keys(),
      ...state.deck.side.keys()
    ]);
    for (const id of allIds) {
      if (!isLegal(id)) illegal.push(id);
      const lim = getLimit(id);
      const t = totalCopiesOf(id);
      if (lim !== null && t > lim) limitIssues.push({id, t, lim});
    }

    // Size rules
    const sizeIssues = [];
    if (main < 40 || main > 60) sizeIssues.push(`Main must be 40–60 (now ${main})`);
    if (extra > 15) sizeIssues.push(`Extra max 15 (now ${extra})`);
    if (side > 15) sizeIssues.push(`Side max 15 (now ${side})`);

    elSizePill.textContent = sizeIssues.length ? `Sizes: ❌` : `Sizes: ✅`;
    elLegalPill.textContent = illegal.length ? `Legality: ❌ ${illegal.length}` : `Legality: ✅ OK`;
    elLimitPill.textContent = limitIssues.length ? `Limits: ❌ ${limitIssues.length}` : `Limits: ✅ OK`;

    if (illegal.length || limitIssues.length || sizeIssues.length) {
      elErrors.style.display = 'block';
      const parts = [];
      if (sizeIssues.length) parts.push(sizeIssues.join(' | '));
      if (illegal.length) parts.push(`Illegal cards (ids): ${illegal.join(', ')}`);
      if (limitIssues.length) parts.push(`Limit exceeded: ${limitIssues.map(x=>`${state.cards[x.id]?.name ?? x.id} (${x.t}/${x.lim})`).join('; ')}`);
      elErrors.innerHTML = parts.join('<br/>');
    } else {
      elErrors.style.display = 'none';
      elErrors.textContent = '';
    }
  }

  function buildFilterOptions() {
    const types = new Set();
    const attrs = new Set();
    const mtypes = new Set();

    for (const id of state.legalIds) {
      const c = state.cards[id];
      if (!c) continue;
      if (c.type) types.add(c.type);
      if (c.attribute) attrs.add(c.attribute);
      if (c.monsterType) mtypes.add(c.monsterType);
    }

    function fillSelect(sel, values) {
      const keepFirst = sel.querySelector('option')?.outerHTML ?? '';
      sel.innerHTML = keepFirst;
      [...values].sort((a,b)=>String(a).localeCompare(String(b))).forEach(v=>{
        const o=document.createElement('option');
        o.value=v; o.textContent=v;
        sel.appendChild(o);
      });
    }

    fillSelect(fType, types);
    fillSelect(fAttr, attrs);
    fillSelect(fMType, mtypes);
  }

  function passesFilters(id) {
    const c = state.cards[id];
    if (!c) return false;

    const t = fType.value;
    const a = fAttr.value;
    const mt = fMType.value;
    const lim = fLimit.value;

    if (t && c.type !== t) return false;
    if (a && c.attribute !== a) return false;
    if (mt && c.monsterType !== mt) return false;
    if (lim !== '') {
      const L = String(getLimit(id) ?? '');
      if (L !== lim) return false;
    }
    return true;
  }

  function renderResults(query) {
    elResults.innerHTML = '';
    const q = (query || '').trim().toLowerCase();

    const matches = [];
    if (q.length === 0) {
      elResults.innerHTML = `<div class="small muted">Escribe para buscar cartas…</div>`;
      elResultCount.textContent = '0';
      return;
    }

    for (const id of state.legalIds) {
      const c = state.cards[id];
      if (!c?.name) continue;
      if (!passesFilters(id)) continue;
      if (c.name.toLowerCase().includes(q)) {
        matches.push(id);
        if (matches.length >= 60) break;
      }
    }

    elResultCount.textContent = String(matches.length);

    if (matches.length === 0) {
      elResults.innerHTML = `<div class="small muted">No results for “${query}”.</div>`;
      return;
    }

    for (const id of matches) {
      const c = state.cards[id];
      const lim = getLimit(id);
      const total = totalCopiesOf(id);
      const canAdd = (lim === null) ? true : (total < lim);

      const row = document.createElement('div');
      row.className = 'card';
      row.innerHTML = `
        <div class="row">
          <div>
            <div class="name">${c.name}</div>
            <div class="meta">${fmtCardMeta(c)}</div>
            <div class="small muted">ID: ${id} • Limit: ${lim ?? '—'} • In deck: ${total}</div>
          </div>
          <div class="btns">
            <button data-act="add" data-id="${id}" ${canAdd ? '' : 'disabled'}>${canAdd ? `Add to ${state.tab}` : 'Max'}</button>
          </div>
        </div>
      `;
      elResults.appendChild(row);
    }
  }

  function setTab(tab) {
    state.tab = tab;
    document.querySelectorAll('.tab').forEach(x=>{
      x.classList.toggle('active', x.getAttribute('data-tab') === tab);
    });
    renderDeck();
    renderResults(elQ.value);
  }

  function exportText() {
    function sectionToLines(title, m) {
      const arr = [...m.entries()].map(([id, qty]) => ({
        id, qty, name: state.cards[id]?.name ?? id
      })).sort((a,b)=>a.name.localeCompare(b.name,'es'));
      const lines = arr.map(it => `${it.qty} ${it.name}`);
      return [`# ${title}`, ...lines, ''];
    }

    const out = [
      `# NeoGoat Deck (${state.meta?.name ?? state.formatId})`,
      '',
      ...sectionToLines('Main', state.deck.main),
      ...sectionToLines('Extra', state.deck.extra),
      ...sectionToLines('Side', state.deck.side),
    ].join('\n');

    return out.trim();
  }

  function saveLocal() {
    const payload = {
      formatId: state.formatId,
      savedAt: new Date().toISOString(),
      main: [...state.deck.main.entries()],
      extra: [...state.deck.extra.entries()],
      side: [...state.deck.side.entries()]
    };
    localStorage.setItem(LS_KEY, JSON.stringify(payload));
  }

  function loadLocal() {
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return false;
    const obj = JSON.parse(raw);

    // allow loading even if format changed, but keep current formatId for validation
    state.deck.main = new Map(obj.main || []);
    state.deck.extra = new Map(obj.extra || []);
    state.deck.side = new Map(obj.side || []);
    renderDeck();
    renderResults(elQ.value);
    return true;
  }

  function clearAll() {
    state.deck.main.clear();
    state.deck.extra.clear();
    state.deck.side.clear();
    renderDeck();
    renderResults(elQ.value);
  }

  function importDeck(text) {
    // Simple import:
    // lines like "2 Card Name"
    // Sections optional: "# Main", "# Extra", "# Side"
    let section = 'main';
    const nameToId = new Map();
    for (const id of state.legalIds) {
      const n = state.cards[id]?.name;
      if (n) nameToId.set(n.toLowerCase(), id);
    }

    clearAll();

    const lines = text.split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
    for (const line of lines) {
      const low = line.toLowerCase();
      if (low.startsWith('#')) {
        if (low.includes('extra')) section = 'extra';
        else if (low.includes('side')) section = 'side';
        else if (low.includes('main')) section = 'main';
        continue;
      }
      const m = line.match(/^(\d+)\s+(.+)$/);
      if (!m) continue;
      const qty = Math.max(1, Math.min(3, parseInt(m[1],10)));
      const name = m[2].trim().toLowerCase();
      const id = nameToId.get(name);
      if (!id) continue;

      // add qty respecting limit
      for (let i=0;i<qty;i++) addTo(section, id);
    }
    renderDeck();
  }

  // Events
  elResults.addEventListener('click', (e) => {
    const btn = e.target.closest('button');
    if (!btn) return;
    const act = btn.getAttribute('data-act');
    const id = btn.getAttribute('data-id');
    if (act === 'add') addTo(state.tab, id);
  });

  elDeck.addEventListener('click', (e) => {
    const btn = e.target.closest('button');
    if (!btn) return;
    const act = btn.getAttribute('data-act');
    const id = btn.getAttribute('data-id');
    if (act === 'add') addTo(state.tab, id);
    if (act === 'sub') subFrom(state.tab, id);
    if (act === 'rm') rmFrom(state.tab, id);
  });

  document.querySelectorAll('.tab').forEach(t=>{
    t.addEventListener('click', ()=>setTab(t.getAttribute('data-tab')));
  });

  document.getElementById('saveBtn').addEventListener('click', ()=>{
    saveLocal();
    alert('Saved locally ✅');
  });

  document.getElementById('loadBtn').addEventListener('click', ()=>{
    const ok = loadLocal();
    alert(ok ? 'Loaded ✅' : 'No local deck found.');
  });

  document.getElementById('newBtn').addEventListener('click', ()=>{
    if (confirm('Clear deck?')) clearAll();
  });

  document.getElementById('exportBtn').addEventListener('click', async () => {
    const text = exportText();
    try {
      await navigator.clipboard.writeText(text);
      alert('Deck copied ✅');
    } catch {
      alert(text);
    }
  });

  document.getElementById('importBtn').addEventListener('click', ()=>{
    const text = prompt('Paste decklist text (supports # Main / # Extra / # Side):');
    if (text) importDeck(text);
  });

  let t = null;
  elQ.addEventListener('input', () => {
    clearTimeout(t);
    t = setTimeout(() => renderResults(elQ.value), 60);
  });

  [fType, fAttr, fMType, fLimit].forEach(sel=>{
    sel.addEventListener('change', ()=>renderResults(elQ.value));
  });

  // Load data (relative paths because your site is served from /data/)
  try {
    elStatus.textContent = 'Cargando formato…';
    const cfg = await (await fetch('./config.json')).json();
    state.formatId = cfg.currentFormatId;

    elStatus.textContent = 'Cargando cartas…';
    state.cards = await (await fetch('./cards_catalog.json')).json();

    elStatus.textContent = 'Cargando reglas del formato…';
    state.meta = await (await fetch(`./formats/${state.formatId}/meta.json`)).json();
    state.rules = await (await fetch(`./formats/${state.formatId}/rules.json`)).json();

    state.legalIds = Object.keys(state.rules).filter(id => state.rules[id]?.legal === true);

    elFormatTag.textContent = `Formato: ${state.meta?.name ?? state.formatId}`;
    elStatus.innerHTML = `Listo ✅ <span class="muted">(${state.legalIds.length} cartas legales)</span>`;

    buildFilterOptions();
    renderResults('');
    renderDeck();

    // auto-load if exists
    loadLocal();
  } catch (err) {
    console.error(err);
    elStatus.textContent = 'Error cargando datos (revisa rutas JSON).';
    elResults.innerHTML = `<div class="err">No pude cargar los JSON. Verifica config/cards/rules.</div>`;
  }
})();
</script>
</body>
</html>
